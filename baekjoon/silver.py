# # 1316번# import sys# N = int(sys.stdin.readline())# group_count = 0## for i in range(N):#     str = sys.stdin.readline()#     chars = []#     last_char = str[0]#     is_group = True#     for char in str:#         if char not in chars:#             chars.append(char)#             last_char = char#         if char in chars:#             if char != last_char:#                 is_group = False#                 break#     if is_group:#         group_count += 1## print(group_count)# 1541번(못품)# list1 = ['-', '+']# str = sys.stdin.readline()# list2 = str.replace('-', ' ').replace('+', ' ').split()# print(list2)# 1051번# 1. sys.std.readline()을 이용하여 입력 문장에 대한 문자 list쉽게 만들기 가능# 2. 처음 list of tuple을 생성할 때 temp_list를 만든 다음에 빈 리스트에 이를 추가# 3. loop문을 별도의 함수로 만들면 더 빨라짐# def get_biggest_area(square):#     biggest_area = 1#     for i in range(N):#         for j in range(M):#             for k in range(M):#                 if j >= k:#                     continue##                 row = square[i]#                 if row[j] == row[k]:#                     dist = k - j#                     num = row[j]#                     if (i + dist) < N and (j + dist) < M:#                         if square[i + dist][j] == num and square[i + dist][j + dist] == num:#                             area = (dist + 1) * (dist + 1)#                             if area > biggest_area:#                                 biggest_area = area##     return biggest_area## N, M = map(int, input().split())# square = list()## for i in range(N):#     row = list(map(int, input()))#     square.append(row)## print(get_biggest_area(square))# 1051번(2)# N, M = map(int, input().split())# square = list()## for i in range(N):#     row = list(map(int, input()))#     square.append(row)## biggest_area = 1# for i in range(N):#     for j in range(M):#         for k in range(M):#             if j >= k:#                 continue##             row = square[i]#             if row[j] == row[k]:#                 dist = k - j#                 num = row[j]#                 if (i + dist) < N and (j + dist) < M:#                     if square[i + dist][j] == num and square[i + dist][j + dist] == num:#                         area = (dist + 1) * (dist + 1)#                         if area > biggest_area:#                             biggest_area = area## print(biggest_area)# 1051번(3) ==> 비추천# N, M = map(int, input().split())# square = list()# start_data = list()  # [시작 좌표, distance, 값]## for i in range(N):#     row = list(map(int, input()))##     for j in range(M):#         for k in range(M):#             if j >= k:#                 continue##             if row[j] == row[k]:#                 start_data.append([(i, j), k-j, row[j]])##     square.append(row)## biggest_area = 1# for data in start_data:#     i = data[0][0]#     j = data[0][1]#     dist = data[1]#     num = data[2]##     if (i + dist) < N and (j + dist) < M:#         if square[i + dist][j] == num and square[i + dist][j + dist] == num:#             area = (dist + 1) * (dist + 1)#             if area > biggest_area:#                 biggest_area = area## print(biggest_area)# 11004번# N, M = map(int, input().split())## nums = list(map(int, input().split()))# nums.sort()# print(nums[M-1])# 11004번(2)# import sys## N, M = map(int, sys.stdin.readline().split())## nums = list(map(int, sys.stdin.readline().split()))# nums.sort()# print(nums[M-1])# 15649번# 1. 재귀는 된다!# ==> 4 2를 입력했을 때, 1, 2, 3, 4에서 1 + (2, 3, 4의 순열), 2 + (1, 3, 4의 순열), 3 + (1, 2, 4의 순열), 4 + (1, 2, 3의 순열)이다.# 2. print(*cur_result)가 for문을 이용해서 출력하는 것보다 훨씬 빠름# import sys## def show_permutation(nums, cur_result, M):#     if M == 0:#         print(*cur_result)#         # for n in cur_result:#         #     print(n, end=' ')#         # print()#         return##     for num in nums:#         cur_result_copy = cur_result.copy()#         cur_result_copy.append(num)##         nums2 = [i for i in nums if i not in cur_result_copy]#         show_permutation(nums2, cur_result_copy, M - 1)### N, M = map(int, sys.stdin.readline().split())# nums = list(range(1, N+1))# show_permutation(nums, [], M)# 15649번(2)# import sys# from itertools import permutations## N, M = map(int, sys.stdin.readline().split())# nums = list(range(1, N+1))## for permutation in permutations(nums, M):#     print(*permutation)# 15650번# import sys## def show_permutation(nums, cur_result, M):#     if M == 0:#         print(*cur_result)#         # for n in cur_result:#         #     print(n, end=' ')#         # print()#         return##     for num in nums:#         cur_result_copy = cur_result.copy()#         cur_result_copy.append(num)##         nums2 = [i for i in nums if i > num]#         show_permutation(nums2, cur_result_copy, M - 1)### N, M = map(int, sys.stdin.readline().split())# nums = list(range(1, N+1))# show_permutation(nums, [], M)# 15650번(2) ==> itertools모듈 이용# import sys# from itertools import combinations## N, M = map(int, sys.stdin.readline().split())# nums = list(range(1, N+1))## for combination in combinations(nums, M):#     print(*combination)# 15651번# import sys# # sys.setrecursionlimit(10**8)## def show_permutation(nums, cur_result, M):#     if M == 0:#         print(*cur_result)#         return##     for num in nums:#         cur_result_copy = cur_result.copy()#         cur_result_copy.append(num)##         show_permutation(nums, cur_result_copy, M - 1)### N, M = map(int, sys.stdin.readline().split())# nums = list(range(1, N+1))# show_permutation(nums, [], M)# 15652번# import sys## def show_permutation(nums, cur_result, M):#     if M == 0:#         print(*cur_result)#         # for n in cur_result:#         #     print(n, end=' ')#         # print()#         return##     for num in nums:#         cur_result_copy = cur_result.copy()#         cur_result_copy.append(num)##         nums2 = [i for i in nums if i >= num]#         show_permutation(nums2, cur_result_copy, M - 1)### N, M = map(int, sys.stdin.readline().split())# nums = list(range(1, N+1))# show_permutation(nums, [], M)# 14889번# import sys# from itertools import combinations## def get_diff(square, N, team1, team2):#     score1 = 0#     score2 = 0##     for i in range(N):#         for j in range(N):#             if i in team1 and j in team1:#                 score1 += square[i][j]#             elif i in team2 and j in team2:#                 score2 += square[i][j]##     return abs(score1 - score2)## N = int(sys.stdin.readline()) # N/2명씩 2팀으로 나눔.# nums = list(range(N))## square = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]## # square = []# ## # for _ in range(N):# #     row = list(map(int, input().split()))# #     square.append(row)## count = 0# min_diff = 999999## for combination in combinations(nums, int(N/2)):#     count += 1##     team1 = combination#     team2 = [num for num in nums if num not in team1]##     temp_diff = get_diff(square, N, team1, team2)#     if min_diff > temp_diff:#         min_diff = temp_diff## print(min_diff)# 14888번# import sys# from itertools import permutations## #  1-2÷3+4+5×6 ==> 54# def get_result(nums, ops):#     N = len(nums)#     result = 0##     if ops[0] == '+':#         result = nums[0] + nums[1]#     elif ops[0] == '-':#         result = nums[0] - nums[1]#     elif ops[0] == 'x':#         result = nums[0] * nums[1]#     elif ops[0] == '/':#         if nums[0] < 0 or nums[1] < 0:#             result = -(abs(nums[0]) // abs(nums[1]))#         else:#             result = nums[0] // nums[1]##     for i in range(1, N-1):#         if ops[i] == '+':#             result = result + nums[i+1]#         elif ops[i] == '-':#             result = result - nums[i+1]#         elif ops[i] == 'x':#             result = result * nums[i+1]#         elif ops[i] == '/':#             if result < 0 or nums[i+1] < 0:#                 result = -(abs(result) // abs(nums[i+1]))#             else:#                 result = result // nums[i+1]##     return result## N = int(sys.stdin.readline())# nums = list(map(int, sys.stdin.readline().split()))# op_count = list(map(int, sys.stdin.readline().split())) # + - x %# ops = ['+'] * op_count[0] + ['-'] * op_count[1] + ['x'] * op_count[2] + ['/'] * op_count[3]## min_result = sys.maxsize# max_result = -sys.maxsize# for permutation in permutations(ops, N-1):#     temp_result = get_result(nums, permutation)##     if min_result > temp_result:#         min_result = temp_result##     if max_result < temp_result:#         max_result = temp_result## print(max_result)# print(min_result)# 2748번# import sys## n = int(sys.stdin.readline())## d = [0 for _ in range(100)]# d[1], d[2] = 1, 1## def fibonacci(n):#     if n == 1: return 1#     if n == 2: return 1##     if d[n] != 0: return d[n]##     d[n] = fibonacci(n-1) + fibonacci(n-2)##     return d[n]## print(fibonacci(n))# 1003번# import sys## counts = {0: (1, 0), 1: (0, 1)} # key: num, value: (0이 출력되는 횟수, 1이 출력되는 횟수)## def fibonacci(n):#     if n == 0: return 0#     if n == 1: return 1##     for i in range(2, n+1):#         counts[i] = (counts[i-1][0] + counts[i-2][0], counts[i-1][1] + counts[i-2][1])### N = int(sys.stdin.readline())## for _ in range(N):#     n = int(sys.stdin.readline())##     if n in counts:#         print(counts[n][0], end=' ')#         print(counts[n][1])#     else:#         fibonacci(n)##         print(counts[n][0], end=' ')#         print(counts[n][1])# 1904번# import sys## d = [0] * 1000001# d[0], d[1], d[2] = 0, 1, 2## N = int(sys.stdin.readline())## for i in range(3, N+1):#     d[i] = d[i-1] % 15746 + d[i-2] % 15746## print(d[N] % 15746)# 1427번 - (1)# import sys## N = int(sys.stdin.readline())## nums = []# while N > 0:#     nums.append(N % 10)##     N = N // 10## nums.sort(reverse=True)# results = 0# for i in range(len(nums)):#     results += nums[i] * 10**(len(nums) - i - 1)# print(results)# 1427번 - (2)# import sys## N = list(sys.stdin.readline().strip())# N.sort(reverse=True)## print(''.join(N))# 1978번 - 아직 못품# import sys## N = int(sys.stdin.readline())# nums = list(map(int, sys.stdin.readline().split()))## result = 0# for num in nums:#     for i in range(2, num+1):#         if i == num:#             result += 1#             break##         if num % i == 0:#             break## print(result)# 10828번 - indexing 안쓰고 한 것# import sys## class Stack:#     def __init__(self):#         self.stack = []#         self.ptr = 0##     def push(self, data):#         self.stack.append(data)#         self.ptr += 1##     def pop(self):#         if self.ptr > 0:#             ret_value = self.stack[self.ptr - 1]#             del self.stack[self.ptr - 1]#             self.ptr -= 1##             return ret_value#         else:#             return -1##     def top(self):#         if self.ptr > 0:#             return self.stack[self.ptr - 1]#         else:#             return -1##     def size(self):#         return self.ptr##     def empty(self):#         if self.ptr > 0:#             return 0#         else:#             return 1### N = int(sys.stdin.readline())# stack = Stack()# for _ in range(N):#     op = sys.stdin.readline().strip().split()##     if 'push' == op[0]:#         data = int(op[1])#         stack.push(data)#     elif 'pop' == op[0]:#         print(stack.pop())#     elif 'size' == op[0]:#         print(stack.size())#     elif 'empty' == op[0]:#         print(stack.empty())#     elif 'top' == op[0]:#         print(stack.top())# 10828번 - indexing 사용# import sys## class Stack:#     def __init__(self):#         self.stack = []##     def push(self, data):#         self.stack.append(data)##     def pop(self):#         if len(self.stack) > 0:#             ret_value = self.stack[-1]#             del self.stack[-1]##             return ret_value#         else:#             return -1##     def top(self):#         if len(self.stack) > 0:#             return self.stack[-1]#         else:#             return -1##     def size(self):#         return len(self.stack)##     def empty(self):#         if len(self.stack) > 0:#             return 0#         else:#             return 1### N = int(sys.stdin.readline())# stack = Stack()# for _ in range(N):#     op = sys.stdin.readline().strip().split()##     if 'push' == op[0]:#         data = int(op[1])#         stack.push(data)#     elif 'pop' == op[0]:#         print(stack.pop())#     elif 'size' == op[0]:#         print(stack.size())#     elif 'empty' == op[0]:#         print(stack.empty())#     elif 'top' == op[0]:#         print(stack.top())# 10773번 - 스택 구현# import sys## class Stack:#     def __init__(self):#         self.stack = []##     def push(self, data):#         self.stack.append(data)##     def pop(self):#         if len(self.stack) > 0:#             ret_value = self.stack[-1]#             del self.stack[-1]##             return ret_value#         else:#             return -1##     def sum(self):#         return sum(self.stack)### K = int(sys.stdin.readline())## stack = Stack()# for _ in range(K):#     num = int(sys.stdin.readline())##     if num == 0:#         _ = stack.pop()#     else:#         stack.push(num)## print(stack.sum())# 10773번 - 스택 구현x# import sys## K = int(sys.stdin.readline())## nums = []# sum = 0# for _ in range(K):#     num = int(sys.stdin.readline())##     if num == 0:#         sum -= nums[-1]#         del nums[-1]#     else:#         sum += num#         nums.append(num)## print(sum)# 9012번# import sys## T = int(sys.stdin.readline())## for _ in range(T):#     stack = []#     string1 = sys.stdin.readline().strip()##     for ch in string1:#         if ch == '(':#             stack.append(ch)#         elif ch == ')':#             if len(stack) > 0:#                 stack.pop()#             else:#                 stack.append(ch)#                 break##     if len(stack) == 0:#         print('YES')#     else:#         print('NO')# 18258번# import sys## class Queue:#     def __init__(self):#         self.queue = []#         self.head = 0#         self.rear = 0##     def push(self, data):#         self.queue.append(data)#         self.rear += 1##     def empty(self):#         if self.rear == self.head:#             return 1#         else:#             return 0##     def pop(self):#         if not self.empty():#             ret_value = self.queue[self.head]#             self.head += 1##             return ret_value#         else:#             return -1##     def size(self):#         return (self.rear - self.head)##     def front(self):#         if not self.empty():#             return self.queue[self.head]#         else:#             return -1##     def back(self):#         if not self.empty() > 0:#             return self.queue[self.rear - 1]#         else:#             return -1### N = int(sys.stdin.readline())# queue = Queue()# for _ in range(N):#     op = sys.stdin.readline().strip().split()##     if 'push' == op[0]:#         data = int(op[1])#         queue.push(data)#     elif 'pop' == op[0]:#         print(queue.pop())#     elif 'size' == op[0]:#         print(queue.size())#     elif 'empty' == op[0]:#         print(queue.empty())#     elif 'front' == op[0]:#         print(queue.front())#     elif 'back' == op[0]:#         print(queue.back())# 2164번 - deque사용 x# import sys## N = int(sys.stdin.readline())# nums = [i+1 for i in range(N)]# front = 0## while True:#     if len(nums) > 1:#         front += 1#     else:#         break##     if len(nums) - front > 1:#         nums.append(nums[front])#         front += 1#     else:#         break## print(nums[front])# 2164번 - deque사용 o# import sys# from collections import deque## N = int(sys.stdin.readline())# deque = deque([i+1 for i in range(N)])## while len(deque) > 1:#     deque.popleft()#     deque.append(deque.popleft())## print(deque[0])# 11866번# import sys# from collections import deque## N, K = map(int, sys.stdin.readline().strip().split())## deq = deque([i+1 for i in range(N)])# print('<', end='')# while len(deq) > 1:#     for i in range(K-1):#         deq.append(deq.popleft())#     print('%d, ' % deq.popleft(), end='')# print('%d>' % deq.popleft())# 10866번# import sys# from collections import deque## T = int(sys.stdin.readline())# for _ in range(T):#     ops = sys.stdin.readline().strip()##     n = int(sys.stdin.readline())#     nums = list(sys.stdin.readline().rstrip()[1:-1].split(','))#     nums = nums[1:-1]#     nums = list(nums.split(','))#     deq = deque(nums)##     is_reverse = False#     is_error = False#     for op in ops:#         if 'R' == op:#             is_reverse = not is_reverse#         elif 'D' == op:#             if len(deq) > 0:#                 if is_reverse:#                     pop = deq.pop()#                 else:#                     pop = deq.popleft()##                 if pop == '':#                     print('error')#                     is_error = True#                     break#             else:#                 print('error')#                 is_error = True#                 break##     if is_reverse:#         deq.reverse()##     if not is_error:#         print('[', end='')#         for i in range(len(deq)):#             if i == (len(deq) - 1):#                 print('%s' % deq[i], end='')#             else:#                 print('%s,' % deq[i], end='')#         print(']')# 1920번 - set이용 x# import sys## def binary_search(arr, target):#     low = 0#     high = len(arr) - 1##     while low <= high:#         mid = (high+low)//2##         if arr[mid] < target:#             low = mid + 1#         elif arr[mid] == target:#             return mid#         elif arr[mid] > target:#             high = mid - 1##     return -1### N = int(sys.stdin.readline())# arr = list(map(int, sys.stdin.readline().rstrip().split(' ')))# arr.sort()# M = int(sys.stdin.readline())# targets = list(map(int, sys.stdin.readline().rstrip().split(' ')))## for target in targets:#     if binary_search(arr, target) == -1:#         print('0')#     else:#         print('1')# 1920번 - set이용# import sys## N = int(sys.stdin.readline())# arr = set(sys.stdin.readline().split())# M = int(sys.stdin.readline())# targets = sys.stdin.readline().split()## for target in targets:#     if target in arr:#         print('1')#     else:#         print('0')# 1931번# import sys## N = int(sys.stdin.readline())## meetings = []# for _ in range(N):#     tp = tuple(map(int, sys.stdin.readline().rstrip().split())) # (start, end)#     meetings.append(tp)## meetings.sort(key=lambda tp: (tp[1], tp[0]))# result = 0# end_time = 0# for meeting in meetings:#     start_time = meeting[0]##     if start_time >= end_time:#         end_time = meeting[1]#         result += 1## print(result)# 1541번# import sys## ops = sys.stdin.readline().rstrip().split('-')## final_nums = []# for op in ops:#     if '+' in op:#         nums = list(map(int, op.split('+')))#         sum = 0#         for num in nums:#             sum += num#         final_nums.append(sum)#     else:#         final_nums.append(int(op))## result = final_nums[0]# for i in range(1, len(final_nums)):#     result -= final_nums[i]## print(result)# 70+20+10-5+10-50-50-50+100+100+10-10# 1541번# import sys## ops = sys.stdin.readline().rstrip().split('-')## for i in range(len(ops)):#     if '+' in ops[i]:#         nums = list(map(int, ops[i].split('+')))#         sum = 0#         for num in nums:#             sum += num##         ops[i] = sum#     else:#         ops[i] = int(ops[i])## result = ops[0]# for i in range(1, len(ops)):#     result -= ops[i]## print(result)# 9461번# import sys## def padovan(d, n):#     if 1 <= n <= 3:#         return 1##     if d[n] != 0:#         return d[n]##     d[n] = padovan(d, n-3) + padovan(d, n-2)##     return d[n]### T = int(sys.stdin.readline())# d = [0 for _ in range(101)]# d[1], d[2], d[3] = 1, 1, 1## for _ in range(T):#     N = int(sys.stdin.readline())#     print(padovan(d, N))# 1932번 - triangle, d 2개 list이용# import sys## # def calc_max(d, triangle, n):# #     for i in range(1, n):# #         for j in range(0, i + 1):# #             if j == 0:# #                 d[i][j] = d[i - 1][j] + triangle[i][j]# #             elif j == i:# #                 d[i][j] = d[i - 1][j - 1] + triangle[i][j]# #             else:# #                 d[i][j] = max(d[i - 1][j - 1], d[i - 1][j]) + triangle[i][j]# ## #     return max(d[n-1][:])## n = int(sys.stdin.readline())# triangle = []# d = []# for _ in range(n):#     nums = list(map(int, sys.stdin.readline().rstrip().split()))#     d.append([0 for _ in range(len(nums))])#     triangle.append(nums)## d[0][0] = triangle[0][0]## for i in range(1, n):#     for j in range(0, i+1):#         if j == 0:#             d[i][j] = d[i-1][j] + triangle[i][j]#         elif j == i:#             d[i][j] = d[i-1][j-1] + triangle[i][j]#         else:#             d[i][j] = max(d[i-1][j-1], d[i-1][j]) + triangle[i][j]## print(max(d[n-1]))# print(calc_max(d, triangle, n))# 1932번 - triangle list 하나 이용(더욱 깔끔)# import sys## n = int(sys.stdin.readline())# triangle = []## for _ in range(n):#     nums = list(map(int, sys.stdin.readline().rstrip().split()))##     triangle.append(nums)## for i in range(1, n):#     for j in range(0, i+1):#         if j == 0:#             triangle[i][j] = triangle[i-1][j] + triangle[i][j]#         elif j == i:#             triangle[i][j] = triangle[i-1][j-1] + triangle[i][j]#         else:#             triangle[i][j] = max(triangle[i-1][j-1], triangle[i-1][j]) + triangle[i][j]## print(max(triangle[n-1]))# 2217번 - 처음 작성# import sys## N = int(sys.stdin.readline())# ropes = []# for _ in range(N):#     rope = int(sys.stdin.readline())#     ropes.append(rope)## ropes.sort(reverse=True)## weight = 0# max_weight = ropes[0]# for i, rope in enumerate(ropes):#     weight = rope * (i+1)##     if weight > max_weight:#         max_weight = weight## print(max_weight)# 2217번 - 간결한 버전# import sys## N = int(sys.stdin.readline())# ropes = [int(sys.stdin.readline()) for _ in range(N)]## ropes.sort(reverse=True)## weight = 0# max_weight = ropes[0]# for i, rope in enumerate(ropes):#     max_weight = max(max_weight, rope*(i+1))## print(max_weight)# 4796번# import sys## i = 0# while True:#     L, P, V = map(int, sys.stdin.readline().rstrip().split())##     if L == 0 and P == 0 and V == 0:#         break##     print('Case %d: %d' % (i+1, L*(V//P) + min(V%P, L)))##     i += 1# 1449번# import sys## N, L = map(int, sys.stdin.readline().split())## locations = list(map(int, sys.stdin.readline().split()))# locations.sort() # 위치가 오름차순 or 내림차순으로 입력된다는 조건이 없으므로## tape_count = 0# start = locations[0] - 0.5# end = locations[0] + 0.5# for loc in locations:#     end = loc + 0.5##     if (end - start) > L:#         tape_count += 1#         start = loc - 0.5## if (end - start) >= 1:#     tape_count += 1## print(tape_count)# 14891번# import sys# from collections import deque## # N극 : 0, S극 : 1# # 초록색 판단 부분 index : 2, 6# wheels = [deque(list(sys.stdin.readline().rstrip())) for _ in range(4)]## def init_rotate(wheel_num, direction):#     if 1 <= wheel_num <= 3:#         # 오른쪽 톱니바퀴 회전 판단#         if wheels[wheel_num-1][2] != wheels[wheel_num][6]:#             rotate(wheel_num+1, -1*direction, True)##     if 2 <= wheel_num <= 4:#         # 왼쪽 톱니바퀴 회전 판단#         if wheels[wheel_num-1][6] != wheels[wheel_num-2][2]:#             rotate(wheel_num-1, -1*direction, False)##     if direction == 1:  # 시계#         wheels[wheel_num - 1].appendleft(wheels[wheel_num - 1].pop())#     elif direction == -1:  # 반시계#         wheels[wheel_num - 1].append(wheels[wheel_num - 1].popleft())### def rotate(wheel_num, direction, next_right=True):#     if next_right and 1 <= wheel_num <= 3:#         # 오른쪽 톱니바퀴 회전 판단#         if wheels[wheel_num-1][2] != wheels[wheel_num][6]:#             rotate(wheel_num+1, -1*direction, True)##     if not next_right and 2 <= wheel_num <= 4:#         # 왼쪽 톱니바퀴 회전 판단#         if wheels[wheel_num-1][6] != wheels[wheel_num-2][2]:#             rotate(wheel_num-1, -1*direction, False)##     if direction == 1:  # 시계#         wheels[wheel_num - 1].appendleft(wheels[wheel_num - 1].pop())#     elif direction == -1:  # 반시계#         wheels[wheel_num - 1].append(wheels[wheel_num - 1].popleft())## def calc_score():#     score = 0##     for i, wheel in enumerate(wheels):#         if wheel[0] == '1':#             score += 2 ** i##     return score### K = int(sys.stdin.readline())## for _ in range(K):#     # wheel_num : 회전시키는 톱니바퀴 번호, direction: 1이면 시계방향, -1이면 반시계방향#     wheel_num, direction = map(int, sys.stdin.readline().rstrip().split())##     init_rotate(wheel_num, direction)## print(calc_score())# 1260번# import sys# from collections import deque## def dfs(graph, visited, start):#     if visited[start]:#         return##     visited[start] = True#     print(start, end=' ')##     for v in graph[start]:#         if not visited[v]:#             dfs(graph, visited, v)### def bfs(graph, visited, start):#     if visited[start]:#         return##     queue = deque()#     queue.append(start)#     visited[start] = True#     print(start, end=' ')##     while queue:#         for v in graph[queue.popleft()]:#             if not visited[v]:#                 visited[v] = True#                 queue.append(v)#                 print(v, end=' ')### N, M, V = map(int, sys.stdin.readline().rstrip().split())## graph = [[] for _ in range(N+1)]# visited = [False for _ in range(N+1)]## for _ in range(M):#     v1, v2 = map(int, sys.stdin.readline().rstrip().split())##     graph[v1].append(v2)#     graph[v2].append(v1)## for v in graph:#     v.sort()## dfs(graph, visited, V)# print()## visited = [False for _ in range(N+1)]# bfs(graph, visited, V)# 2606번 ==> BFS# import sys# from collections import deque## def bfs(graph, visited, start):#     if visited[start]:#         return##     num_find = 0##     queue = deque()#     queue.append(start)#     visited[start] = True##     while queue:#         for v in graph[queue.popleft()]:#             if not visited[v]:#                 visited[v] = True#                 queue.append(v)##                 num_find += 1##     return num_find## num_computer = int(sys.stdin.readline())# num_pair = int(sys.stdin.readline())## graph = [[] for _ in range(num_computer+1)]## for _ in range(num_pair):#     v1, v2 = map(int, sys.stdin.readline().rstrip().split())##     graph[v1].append(v2)#     graph[v2].append(v1)## visited = [False for _ in range(num_computer+1)]## print(bfs(graph, visited, 1))# 2667번import syssys.setrecursionlimit(10**9)house_num = 0house_nums = []def dfs(house_map, visited, start_row, start_col):    if visited[start_row][start_col]:        return    global house_num    dx = [0, 0, -1, 1] # 상 하 좌 우    dy = [-1, 1, 0, 0]    house_num += 1    visited[start_row][start_col] = True    for i in range(len(dx)):        if 0 <= start_row + dy[i] < len(house_map) and 0 <= start_col + dx[i] < len(house_map[start_row+dy[i]]):            if house_map[start_row+dy[i]][start_col+dx[i]] == '1' and not visited[start_row+dy[i]][start_col+dx[i]]:                dfs(house_map, visited, start_row+dy[i], start_col+dx[i])N = int(sys.stdin.readline())house_map = [sys.stdin.readline().rstrip() for _ in range(N)]visited = [[False] * N for _ in range(N)]group_count = 0for i in range(len(house_map)):    for j in range(len(house_map[i])):        if house_map[i][j] == '1' and not visited[i][j]:            dfs(house_map, visited, i, j)            group_count += 1            if house_num != 0:                house_nums.append(house_num)                house_num = 0print(group_count)house_nums.sort()for house_num in house_nums:    print(house_num)